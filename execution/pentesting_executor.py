"""
Pentesting Executor (Priority 1, Item 4 - Algorithm 6)

Main execution loop that orchestrates:
- Task queue management with retry logic
- Sandbox execution with timeout enforcement
- Safety violation detection and emergency abort
- PPO training integration
- Execution result tracking
"""

import sys
import os
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from typing import List, Dict, Optional, Tuple
from dataclasses import dataclass
import time
from pathlib import Path
import heapq
from enum import Enum

from task_manager import ExploitTask, TaskState
from execution.sandbox_executor import SandboxExecutor, ExecutionResult
from execution.persistent_memory import PersistentMemory
from execution.terrain_generator import TerrainGenerator
from parser import VAFinding


class ExecutionStatus(Enum):
    """Execution status codes"""
    SUCCESS = "success"
    FAILURE = "failure"
    TIMEOUT = "timeout"
    SAFETY_VIOLATION = "safety_violation"
    MAX_ATTEMPTS_REACHED = "max_attempts_reached"
    ABORTED = "aborted"


@dataclass
class ExecutionLimits:
    """Limits for execution"""
    max_attempts_per_task: int = 3
    max_total_attempts: int = 1000
    max_safety_violations: int = 5
    timeout_per_task: int = 30
    exponential_backoff: bool = True
    backoff_base: float = 2.0


@dataclass
class PPOConfig:
    """Configuration for PPO training"""
    enable: bool = False
    train_every_n_episodes: int = 10
    n_training_epochs: int = 10
    batch_size: int = 64
    model_save_path: str = "models/ppo_pentesting.pt"


@dataclass
class ExecutionMetrics:
    """Metrics from execution run"""
    total_tasks: int = 0
    successful_tasks: int = 0
    failed_tasks: int = 0
    timed_out_tasks: int = 0
    safety_violations: int = 0
    total_attempts: int = 0
    total_duration: float = 0.0
    success_rate: float = 0.0


class PentestingExecutor:
    """
    Main pentesting execution orchestrator (Algorithm 6).

    Manages:
    - Task queue with priority
    - Retry logic with exponential backoff
    - Sandbox execution
    - Safety monitoring
    - PPO training (optional)
    - Result tracking
    """

    def __init__(self,
                 sandbox_executor: SandboxExecutor,
                 persistent_memory: PersistentMemory,
                 exec_limits: ExecutionLimits = None,
                 ppo_config: PPOConfig = None,
                 verbose: bool = True):
        """
        Initialize pentesting executor.

        Args:
            sandbox_executor: Sandbox for safe execution
            persistent_memory: Persistent memory for history
            exec_limits: Execution limits and constraints
            ppo_config: PPO training configuration
            verbose: Print detailed progress
        """
        self.sandbox = sandbox_executor
        self.memory = persistent_memory
        self.limits = exec_limits or ExecutionLimits()
        self.ppo_config = ppo_config or PPOConfig()
        self.verbose = verbose

        # Task queue (priority queue: negative priority for max-heap)
        self.task_queue: List[Tuple[float, ExploitTask]] = []
        self.task_attempts: Dict[str, int] = {}
        self.task_status: Dict[str, ExecutionStatus] = {}

        # Execution state
        self.total_attempts = 0
        self.safety_violations = 0
        self.aborted = False
        self.metrics = ExecutionMetrics()

        # PPO agent (if enabled)
        self.ppo_agent = None
        if self.ppo_config.enable:
            self._init_ppo_agent()

    def _init_ppo_agent(self):
        """Initialize PPO agent for training"""
        try:
            from ppo.ppo_agent import PPOAgent
            # Will be properly initialized with state/action dims from environment
            self.ppo_agent = None  # Placeholder
            if self.verbose:
                print("âœ“ PPO training enabled")
        except ImportError:
            print("âš  PPO agent not available, disabling training")
            self.ppo_config.enable = False

    def run_and_validate(self,
                        tasks: List[ExploitTask],
                        terrains: Optional[List] = None) -> ExecutionMetrics:
        """
        Main execution loop (Algorithm 6).

        Args:
            tasks: List of exploitation tasks
            terrains: Optional list of terrain environments

        Returns:
            ExecutionMetrics with results
        """
        start_time = time.time()

        # Initialize task queue
        self._init_task_queue(tasks)

        if self.verbose:
            print("="*70)
            print("Pentesting Executor - Starting Execution")
            print("="*70)
            print(f"Total tasks: {len(tasks)}")
            print(f"Max attempts per task: {self.limits.max_attempts_per_task}")
            print(f"PPO training: {'enabled' if self.ppo_config.enable else 'disabled'}")
            print("="*70 + "\n")

        # Main execution loop
        episode = 0
        while self.task_queue and not self.aborted:
            # Check global limits
            if self.total_attempts >= self.limits.max_total_attempts:
                if self.verbose:
                    print(f"\nâš  Reached max total attempts ({self.limits.max_total_attempts})")
                break

            if self.safety_violations >= self.limits.max_safety_violations:
                if self.verbose:
                    print(f"\nðŸš¨ EMERGENCY ABORT: Too many safety violations ({self.safety_violations})")
                self.aborted = True
                break

            # Get next task
            priority, task = heapq.heappop(self.task_queue)

            # Check task-specific limits
            if self.task_attempts[task.task_id] >= self.limits.max_attempts_per_task:
                self.task_status[task.task_id] = ExecutionStatus.MAX_ATTEMPTS_REACHED
                self.metrics.failed_tasks += 1
                continue

            # Execute task
            episode += 1
            result = self._execute_task(task, episode)

            # Process result
            self._process_result(task, result)

            # Update task state
            if result.status == ExecutionStatus.SUCCESS:
                self.task_status[task.task_id] = ExecutionStatus.SUCCESS
                self.metrics.successful_tasks += 1
            elif result.status == ExecutionStatus.SAFETY_VIOLATION:
                self.task_status[task.task_id] = ExecutionStatus.SAFETY_VIOLATION
                self.metrics.failed_tasks += 1
                self.safety_violations += 1
            elif self.task_attempts[task.task_id] < self.limits.max_attempts_per_task:
                # Retry with backoff
                backoff_delay = self._calculate_backoff(self.task_attempts[task.task_id])
                if self.verbose:
                    print(f"  â³ Retrying in {backoff_delay:.1f}s (attempt {self.task_attempts[task.task_id] + 1}/{self.limits.max_attempts_per_task})")
                time.sleep(backoff_delay)
                heapq.heappush(self.task_queue, (priority, task))
            else:
                self.task_status[task.task_id] = ExecutionStatus.MAX_ATTEMPTS_REACHED
                self.metrics.failed_tasks += 1

            # PPO training checkpoint
            if self.ppo_config.enable and episode % self.ppo_config.train_every_n_episodes == 0:
                self._train_ppo()

        # Calculate final metrics
        self.metrics.total_tasks = len(tasks)
        self.metrics.total_attempts = self.total_attempts
        self.metrics.total_duration = time.time() - start_time
        if self.metrics.total_tasks > 0:
            self.metrics.success_rate = self.metrics.successful_tasks / self.metrics.total_tasks

        if self.verbose:
            self._print_summary()

        return self.metrics

    def _init_task_queue(self, tasks: List[ExploitTask]):
        """Initialize priority queue with tasks"""
        for task in tasks:
            # Priority = negative of task priority (for max-heap)
            priority = -task.priority
            heapq.heappush(self.task_queue, (priority, task))
            self.task_attempts[task.task_id] = 0

    def _execute_task(self, task: ExploitTask, episode: int) -> Dict:
        """
        Execute a single task.

        Args:
            task: Task to execute
            episode: Episode number

        Returns:
            Dictionary with execution result
        """
        self.task_attempts[task.task_id] += 1
        self.total_attempts += 1

        if self.verbose:
            print(f"\n[Episode {episode}] Executing: {task.task_id}")
            print(f"  Target: {task.target_host}:{task.target_port}")
            print(f"  Vulnerability: {task.vulnerability_id}")
            print(f"  CVSS: {task.cvss_score}")
            print(f"  Attempt: {self.task_attempts[task.task_id]}/{self.limits.max_attempts_per_task}")

        # Generate or retrieve exploit script
        script_path = self._get_exploit_script(task)

        if not script_path:
            if self.verbose:
                print(f"  âœ— No exploit script available")
            return {
                'status': ExecutionStatus.FAILURE,
                'duration': 0.0,
                'error': 'No exploit script'
            }

        # Calculate timeout with exponential increase for retries
        timeout = self.limits.timeout_per_task
        if self.limits.exponential_backoff:
            timeout = int(timeout * (self.limits.backoff_base ** (self.task_attempts[task.task_id] - 1)))
            timeout = min(timeout, self.limits.timeout_per_task * 4)  # Cap at 4x

        # Execute in sandbox
        exec_result = self.sandbox.execute_task(
            task_id=task.task_id,
            script_path=script_path,
            timeout=timeout
        )

        # Check for safety violations
        if exec_result.safety_violations:
            if self.verbose:
                print(f"  ðŸš¨ SAFETY VIOLATION: {exec_result.safety_violations}")
            status = ExecutionStatus.SAFETY_VIOLATION
        elif exec_result.status == "timeout":
            if self.verbose:
                print(f"  â± Timed out after {exec_result.duration:.2f}s")
            status = ExecutionStatus.TIMEOUT
            self.metrics.timed_out_tasks += 1
        elif exec_result.exit_code == 0:
            if self.verbose:
                print(f"  âœ“ Success in {exec_result.duration:.2f}s")
            status = ExecutionStatus.SUCCESS
        else:
            if self.verbose:
                print(f"  âœ— Failed (exit code: {exec_result.exit_code})")
            status = ExecutionStatus.FAILURE

        return {
            'status': status,
            'exec_result': exec_result,
            'duration': exec_result.duration,
            'error': exec_result.stderr
        }

    def _get_exploit_script(self, task: ExploitTask) -> Optional[str]:
        """
        Get exploit script for task (from memory or generate new).

        Args:
            task: Task to get script for

        Returns:
            Path to script file or None
        """
        # Try to get best known script from memory
        best_script = self.memory.get_best_script(
            finding_type=task.description,
            cve=task.vulnerability_id,
            service=task.protocol
        )

        if best_script:
            # Save to temporary file
            script_path = Path(f"/tmp/exploit_{task.task_id}.py")
            script_path.write_text(best_script)
            return str(script_path)

        # TODO: Generate new script via LLM (will be implemented in llm_drl_bridge)
        # For now, return None
        return None

    def _process_result(self, task: ExploitTask, result: Dict):
        """
        Process execution result and store in memory.

        Args:
            task: Executed task
            result: Execution result
        """
        # Store in persistent memory
        if 'exec_result' in result:
            exec_result = result['exec_result']
            self.memory.store_outcome(
                finding_type=task.description,
                cve=task.vulnerability_id,
                service=task.protocol,
                target_os="unknown",  # TODO: Get from task
                script_content=exec_result.stdout,  # Placeholder
                success=result['status'] == ExecutionStatus.SUCCESS,
                error_message=result.get('error', ''),
                execution_trace=exec_result.stderr,
                cvss_score=task.cvss_score,
                metadata={
                    'task_id': task.task_id,
                    'target': task.target_host,
                    'port': task.target_port,
                    'attempts': self.task_attempts[task.task_id]
                }
            )

    def _calculate_backoff(self, attempt: int) -> float:
        """Calculate exponential backoff delay"""
        if not self.limits.exponential_backoff:
            return 0.0

        return self.limits.backoff_base ** attempt

    def _train_ppo(self):
        """Train PPO agent (checkpoint during execution)"""
        if not self.ppo_agent:
            return

        if self.verbose:
            print("\n  ðŸ¤– PPO training checkpoint...")

        # TODO: Implement PPO training
        # Will collect trajectories and update policy

    def _print_summary(self):
        """Print execution summary"""
        print("\n" + "="*70)
        print("Execution Complete - Summary")
        print("="*70)
        print(f"Total Tasks:         {self.metrics.total_tasks}")
        print(f"Successful:          {self.metrics.successful_tasks}")
        print(f"Failed:              {self.metrics.failed_tasks}")
        print(f"Timed Out:           {self.metrics.timed_out_tasks}")
        print(f"Safety Violations:   {self.metrics.safety_violations}")
        print(f"Total Attempts:      {self.metrics.total_attempts}")
        print(f"Success Rate:        {self.metrics.success_rate*100:.1f}%")
        print(f"Total Duration:      {self.metrics.total_duration:.2f}s")
        print(f"Aborted:             {'Yes' if self.aborted else 'No'}")
        print("="*70)

    def get_metrics(self) -> ExecutionMetrics:
        """Get execution metrics"""
        return self.metrics

    def abort(self):
        """Emergency abort execution"""
        self.aborted = True
        if self.verbose:
            print("\nðŸš¨ EXECUTION ABORTED")
