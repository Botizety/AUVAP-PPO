#!/usr/bin/env python3
"""
Complete PPO Pentest Training Workflow

This script orchestrates the entire pipeline:
1. Parse Nessus scan
2. Classify vulnerabilities with LLM
3. Generate exploit scripts with LLM
4. Train PPO agent with sequential masking
5. Evaluate trained model

Usage:
    python scripts/complete_pentest_workflow.py \\
        --nessus-scan data/sample_scan.xml \\
        --mode full \\
        --timesteps 50000
"""

import os
import sys
from pathlib import Path
import argparse
import subprocess
from datetime import datetime

sys.path.insert(0, str(Path(__file__).parent.parent))


def run_step(step_name: str, description: str, command: list, verbose: bool = True):
    """Run a workflow step"""
    if verbose:
        print("\n" + "="*70)
        print(f"STEP: {step_name}")
        print(f"Description: {description}")
        print("="*70)
        print(f"Command: {' '.join(command)}\n")

    try:
        result = subprocess.run(
            command,
            check=True,
            capture_output=not verbose,
            text=True
        )

        if verbose:
            print(f"\n✓ {step_name} completed successfully")

        return True

    except subprocess.CalledProcessError as e:
        print(f"\n✗ {step_name} failed!")
        if e.stderr:
            print(f"Error: {e.stderr}")
        return False


def complete_workflow(
    nessus_scan: str,
    output_dir: str = "./pentest_output",
    llm_provider: str = "openai",
    timesteps: int = 50000,
    use_real_execution: bool = False,
    cvss_filter: float = 0.0,
    verbose: bool = True
):
    """
    Run complete pentest training workflow.

    Args:
        nessus_scan: Path to Nessus XML scan
        output_dir: Output directory for all artifacts
        llm_provider: LLM provider for classification and script generation
        timesteps: PPO training timesteps
        use_real_execution: Execute actual scripts during training
        cvss_filter: Only process vulnerabilities with CVSS >= this
        verbose: Print detailed output
    """
    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')

    print("\n" + "="*70)
    print("COMPLETE PPO PENTEST TRAINING WORKFLOW")
    print("="*70)
    print(f"Nessus scan: {nessus_scan}")
    print(f"Output directory: {output_dir}")
    print(f"LLM provider: {llm_provider}")
    print(f"Training timesteps: {timesteps}")
    print(f"Real execution: {'Yes' if use_real_execution else 'No (simulation)'}")
    print(f"CVSS filter: >= {cvss_filter}")
    print("="*70)

    # File paths
    experiment_report = output_dir / f"experiment_report_{timestamp}.json"
    exploits_manifest = output_dir / f"exploits_manifest_{timestamp}.json"
    exploits_dir = output_dir / "exploits"
    checkpoints_dir = output_dir / "checkpoints"
    logs_dir = output_dir / "logs"

    # Step 1: Parse and Classify
    print("\n" + "="*70)
    print("STEP 1: Parse Nessus Scan and Classify Vulnerabilities")
    print("="*70)

    success = run_step(
        step_name="Parse & Classify",
        description="Parse Nessus XML and classify vulnerabilities with LLM",
        command=[
            sys.executable,
            "experiment.py",
            "--nessus-file", str(nessus_scan),
            "--output", str(experiment_report),
            "--llm-provider", llm_provider
        ],
        verbose=verbose
    )

    if not success:
        print("\n✗ Workflow failed at Step 1: Classification")
        return False

    # Step 2: Generate Exploit Scripts
    print("\n" + "="*70)
    print("STEP 2: Generate Exploit Scripts with LLM")
    print("="*70)

    success = run_step(
        step_name="Script Generation",
        description="Generate exploit scripts for classified vulnerabilities",
        command=[
            sys.executable,
            "scripts/generate_exploits_from_classification.py",
            "--experiment-report", str(experiment_report),
            "--output-dir", str(exploits_dir),
            "--manifest-output", str(exploits_manifest),
            "--llm-provider", llm_provider,
            "--filter-cvss", str(cvss_filter)
        ] + (["--quiet"] if not verbose else []),
        verbose=verbose
    )

    if not success:
        print("\n✗ Workflow failed at Step 2: Script Generation")
        return False

    # Step 3: Train PPO Agent
    print("\n" + "="*70)
    print("STEP 3: Train PPO Agent with Sequential Masking")
    print("="*70)

    training_command = [
        sys.executable,
        "training/train_ppo_priority.py",
        "--experiment-report", str(experiment_report),
        "--exploits-manifest", str(exploits_manifest),
        "--timesteps", str(timesteps),
        "--save-dir", str(checkpoints_dir),
        "--log-dir", str(logs_dir)
    ]

    if use_real_execution:
        training_command.append("--real-execution")

    success = run_step(
        step_name="PPO Training",
        description="Train PPO agent with sequential masking",
        command=training_command,
        verbose=verbose
    )

    if not success:
        print("\n✗ Workflow failed at Step 3: PPO Training")
        return False

    # Step 4: Summary
    print("\n" + "="*70)
    print("WORKFLOW COMPLETE!")
    print("="*70)
    print(f"\nGenerated artifacts:")
    print(f"  - Experiment report: {experiment_report}")
    print(f"  - Exploits manifest: {exploits_manifest}")
    print(f"  - Exploit scripts: {exploits_dir}/")
    print(f"  - Model checkpoints: {checkpoints_dir}/")
    print(f"  - Training logs: {logs_dir}/")

    print(f"\nNext steps:")
    print(f"1. Review training logs:")
    print(f"   tensorboard --logdir {logs_dir}")
    print(f"\n2. Evaluate trained model:")
    print(f"   python training/evaluate_ppo.py \\")
    print(f"       --model {checkpoints_dir}/ppo_masked_*/final_model.zip \\")
    print(f"       --num-episodes 50")
    print(f"\n3. Use model for pentest automation")

    return True


def main():
    parser = argparse.ArgumentParser(
        description="Complete PPO pentest training workflow"
    )

    # Required
    parser.add_argument("--nessus-scan", type=str, required=True,
                       help="Path to Nessus XML scan file")

    # Mode selection
    parser.add_argument("--mode", type=str, default="full",
                       choices=["full", "classify-only", "generate-only", "train-only"],
                       help="Workflow mode")

    # Workflow options
    parser.add_argument("--output-dir", type=str, default="./pentest_output",
                       help="Output directory for all artifacts")
    parser.add_argument("--llm-provider", type=str, default="openai",
                       choices=["openai", "gemini", "local"],
                       help="LLM provider")

    # Training options
    parser.add_argument("--timesteps", type=int, default=50000,
                       help="PPO training timesteps")
    parser.add_argument("--real-execution", action="store_true",
                       help="Execute actual scripts during training")

    # Filtering
    parser.add_argument("--cvss-filter", type=float, default=0.0,
                       help="Only process CVSS >= this value")

    # Other
    parser.add_argument("--quiet", action="store_true",
                       help="Reduce output verbosity")

    args = parser.parse_args()

    # Check API key
    if args.llm_provider == "openai" and not os.environ.get("OPENAI_API_KEY"):
        print("✗ Error: OPENAI_API_KEY not set")
        print("  Set it with: export OPENAI_API_KEY='sk-...'")
        sys.exit(1)
    elif args.llm_provider == "gemini" and not os.environ.get("GOOGLE_API_KEY"):
        print("✗ Error: GOOGLE_API_KEY not set")
        print("  Set it with: export GOOGLE_API_KEY='...'")
        sys.exit(1)

    # Check Nessus file exists
    if not Path(args.nessus_scan).exists():
        print(f"✗ Error: Nessus scan file not found: {args.nessus_scan}")
        sys.exit(1)

    # Run workflow
    success = complete_workflow(
        nessus_scan=args.nessus_scan,
        output_dir=args.output_dir,
        llm_provider=args.llm_provider,
        timesteps=args.timesteps,
        use_real_execution=args.real_execution,
        cvss_filter=args.cvss_filter,
        verbose=not args.quiet
    )

    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
