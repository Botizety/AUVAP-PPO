#!/usr/bin/env python3
"""
Generate Exploit Scripts from Classification Output

This script:
1. Loads classification results (experiment_report.json)
2. Uses LLM to generate exploit scripts for each vulnerability
3. Saves scripts to exploits/ directory
4. Updates exploits_manifest.json with script paths

Usage:
    python scripts/generate_exploits_from_classification.py \\
        --experiment-report experiment_report_20240115.json \\
        --output-dir ./exploits \\
        --llm-provider openai
"""

import os
import sys
from pathlib import Path
from datetime import datetime
import argparse
import json

sys.path.insert(0, str(Path(__file__).parent.parent))

from typing import List, Dict, Optional
from dataclasses import asdict

from parser import VAFinding
from task_manager import ExploitTask, TaskManager
from exploit_generator import ExploitGenerator


class LLMExploitScriptGenerator:
    """
    Generates exploit scripts using LLM based on classification output.
    """

    def __init__(self,
                 llm_provider: str = "openai",
                 output_dir: str = "./exploits",
                 verbose: bool = True):
        """
        Initialize LLM exploit generator.

        Args:
            llm_provider: LLM provider (openai, gemini, local)
            output_dir: Directory to save generated scripts
            verbose: Print progress
        """
        self.llm_provider = llm_provider
        self.output_dir = Path(output_dir)
        self.verbose = verbose

        # Create output directory
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # Initialize LLM client
        self._init_llm_client()

    def _init_llm_client(self):
        """Initialize LLM client"""
        if self.verbose:
            print(f"Initializing LLM client ({self.llm_provider})...")

        # Import existing classifier for LLM
        try:
            if self.llm_provider == "openai":
                import openai
                api_key = os.environ.get("OPENAI_API_KEY")
                if not api_key:
                    raise ValueError("OPENAI_API_KEY not set")
                self.client = openai.OpenAI(api_key=api_key)
                self.model = "gpt-4"

            elif self.llm_provider == "gemini":
                import google.generativeai as genai
                api_key = os.environ.get("GOOGLE_API_KEY")
                if not api_key:
                    raise ValueError("GOOGLE_API_KEY not set")
                genai.configure(api_key=api_key)
                self.client = genai.GenerativeModel('gemini-pro')
                self.model = "gemini-pro"

            elif self.llm_provider == "local":
                # Placeholder for local LLM
                self.client = None
                self.model = "local"
                if self.verbose:
                    print("⚠ Local LLM not fully implemented, using templates")
            else:
                raise ValueError(f"Unknown provider: {self.llm_provider}")

            if self.verbose:
                print(f"✓ LLM client initialized ({self.model})")

        except Exception as e:
            if self.verbose:
                print(f"✗ Failed to initialize LLM: {e}")
                print("  Will use template-based generation")
            self.client = None

    def generate_script_for_task(self,
                                 finding: VAFinding,
                                 task: ExploitTask) -> Optional[str]:
        """
        Generate exploit script for a single task.

        Args:
            finding: Vulnerability finding
            task: Exploitation task

        Returns:
            Generated script content or None
        """
        if self.verbose:
            print(f"\n  Generating script for: {task.task_id}")
            print(f"    CVE: {finding.plugin_id}")
            print(f"    Target: {task.target_host}:{task.target_port}")
            print(f"    CVSS: {task.cvss_score}")

        # Build prompt for LLM
        prompt = self._build_generation_prompt(finding, task)

        # Generate script
        if self.client:
            script = self._call_llm(prompt)
        else:
            # Fallback to template
            script = self._generate_template_script(finding, task)

        if script and self.verbose:
            print(f"    ✓ Generated ({len(script)} chars)")

        return script

    def _build_generation_prompt(self,
                                 finding: VAFinding,
                                 task: ExploitTask) -> str:
        """Build prompt for LLM script generation"""

        # Determine script language based on service
        language = self._determine_language(finding)

        prompt = f"""Generate a penetration testing exploit script for the following vulnerability.

**Target Information:**
- Host: {task.target_host}
- Port: {task.target_port}
- Service: {finding.protocol or 'unknown'}
- Service Name: {finding.svc_name or 'unknown'}

**Vulnerability Details:**
- Plugin ID: {finding.plugin_id}
- CVE: {finding.cve if hasattr(finding, 'cve') else 'N/A'}
- Name: {finding.plugin_name}
- Severity: {finding.severity}
- CVSS Score: {finding.cvss_base_score or 'N/A'}
- Synopsis: {finding.synopsis}
- Description: {finding.description[:500] if finding.description else 'N/A'}

**Script Requirements:**
1. Language: {language}
2. Must be safe and non-destructive
3. Include proper error handling
4. Accept target host/port as arguments
5. Return exit code 0 on success, non-zero on failure
6. Print clear success/failure messages
7. Include timeout handling (30 seconds max)
8. No hardcoded credentials

**Output Format:**
- Print "SUCCESS" to stdout if exploit succeeds
- Print error details to stderr if it fails
- Use JSON for structured output (optional)

**Safety Constraints:**
- Network operations only (no file system destruction)
- Must validate inputs
- Include connection timeouts
- Clean up resources properly

Generate a complete, working exploit script that follows these requirements.
"""

        return prompt

    def _determine_language(self, finding: VAFinding) -> str:
        """Determine best scripting language for exploit"""
        service = (finding.protocol or '').lower()
        svc_name = (finding.svc_name or '').lower()

        # Windows services prefer PowerShell
        if 'smb' in svc_name or 'windows' in svc_name or finding.port == "445":
            return "PowerShell"

        # SSH/Linux services prefer Bash
        elif 'ssh' in svc_name or finding.port == "22":
            return "Bash"

        # Default to Python (most flexible)
        else:
            return "Python 3"

    def _call_llm(self, prompt: str) -> Optional[str]:
        """Call LLM API to generate script"""
        try:
            if self.llm_provider == "openai":
                response = self.client.chat.completions.create(
                    model=self.model,
                    messages=[
                        {"role": "system", "content": "You are a penetration testing expert who writes safe, ethical exploit code for authorized security testing."},
                        {"role": "user", "content": prompt}
                    ],
                    temperature=0.7,
                    max_tokens=2000
                )
                script = response.choices[0].message.content

                # Extract code block if present
                script = self._extract_code_block(script)
                return script

            elif self.llm_provider == "gemini":
                response = self.client.generate_content(prompt)
                script = response.text
                script = self._extract_code_block(script)
                return script

        except Exception as e:
            if self.verbose:
                print(f"    ✗ LLM generation failed: {e}")
            return None

    def _extract_code_block(self, text: str) -> str:
        """Extract code from markdown code blocks"""
        import re

        # Look for ```language ... ``` blocks
        pattern = r'```(?:python|bash|powershell|sh)?\n(.*?)```'
        matches = re.findall(pattern, text, re.DOTALL)

        if matches:
            return matches[0].strip()

        # If no code block, return as-is
        return text.strip()

    def _generate_template_script(self,
                                  finding: VAFinding,
                                  task: ExploitTask) -> str:
        """Generate template-based script (fallback)"""

        language = self._determine_language(finding)

        if language == "Python 3":
            return self._python_template(finding, task)
        elif language == "PowerShell":
            return self._powershell_template(finding, task)
        elif language == "Bash":
            return self._bash_template(finding, task)
        else:
            return self._python_template(finding, task)

    def _python_template(self, finding: VAFinding, task: ExploitTask) -> str:
        """Python exploit template"""
        return f"""#!/usr/bin/env python3
\"\"\"
Exploit for: {finding.plugin_name}
Target: {task.target_host}:{task.target_port}
CVE: {finding.plugin_id}
CVSS: {finding.cvss_base_score}

Generated by AUVAP-PPO
\"\"\"

import sys
import socket
import argparse
from typing import Tuple

def exploit(target_host: str, target_port: int, timeout: int = 30) -> Tuple[bool, str]:
    \"\"\"
    Attempt to exploit the vulnerability.

    Args:
        target_host: Target IP address
        target_port: Target port
        timeout: Connection timeout in seconds

    Returns:
        Tuple of (success: bool, message: str)
    \"\"\"
    try:
        # TODO: Implement actual exploit logic
        # This is a placeholder template

        # Example: Test if port is open
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)

        result = sock.connect_ex((target_host, target_port))
        sock.close()

        if result == 0:
            return True, f"Port {{target_port}} is open on {{target_host}}"
        else:
            return False, f"Port {{target_port}} is closed or filtered"

    except socket.timeout:
        return False, "Connection timeout"
    except socket.error as e:
        return False, f"Socket error: {{e}}"
    except Exception as e:
        return False, f"Unexpected error: {{e}}"

def main():
    parser = argparse.ArgumentParser(description="Exploit {finding.plugin_id}")
    parser.add_argument("--host", default="{task.target_host}", help="Target host")
    parser.add_argument("--port", type=int, default={task.target_port}, help="Target port")
    parser.add_argument("--timeout", type=int, default=30, help="Timeout in seconds")

    args = parser.parse_args()

    print(f"[*] Attempting exploit on {{args.host}}:{{args.port}}")

    success, message = exploit(args.host, args.port, args.timeout)

    if success:
        print(f"[+] SUCCESS: {{message}}")
        sys.exit(0)
    else:
        print(f"[-] FAILED: {{message}}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
"""

    def _powershell_template(self, finding: VAFinding, task: ExploitTask) -> str:
        """PowerShell exploit template"""
        return f"""# Exploit for: {finding.plugin_name}
# Target: {task.target_host}:{task.target_port}
# CVE: {finding.plugin_id}

param(
    [string]$TargetHost = "{task.target_host}",
    [int]$TargetPort = {task.target_port},
    [int]$Timeout = 30
)

function Invoke-Exploit {{
    param($Host, $Port)

    try {{
        # TODO: Implement exploit logic
        $tcpClient = New-Object System.Net.Sockets.TcpClient
        $connect = $tcpClient.BeginConnect($Host, $Port, $null, $null)
        $wait = $connect.AsyncWaitHandle.WaitOne($Timeout * 1000, $false)

        if ($wait) {{
            $tcpClient.EndConnect($connect)
            $tcpClient.Close()
            Write-Host "[+] SUCCESS: Port $Port is open"
            return $true
        }} else {{
            Write-Error "[-] FAILED: Connection timeout"
            return $false
        }}
    }} catch {{
        Write-Error "[-] FAILED: $_"
        return $false
    }}
}}

$result = Invoke-Exploit -Host $TargetHost -Port $TargetPort

if ($result) {{
    exit 0
}} else {{
    exit 1
}}
"""

    def _bash_template(self, finding: VAFinding, task: ExploitTask) -> str:
        """Bash exploit template"""
        return f"""#!/bin/bash
# Exploit for: {finding.plugin_name}
# Target: {task.target_host}:{task.target_port}
# CVE: {finding.plugin_id}

TARGET_HOST="${{1:-{task.target_host}}}"
TARGET_PORT="${{2:-{task.target_port}}}"
TIMEOUT=30

echo "[*] Attempting exploit on $TARGET_HOST:$TARGET_PORT"

# TODO: Implement exploit logic
# This is a placeholder template

# Example: Check if port is open
timeout $TIMEOUT bash -c "echo >/dev/tcp/$TARGET_HOST/$TARGET_PORT" 2>/dev/null

if [ $? -eq 0 ]; then
    echo "[+] SUCCESS: Port $TARGET_PORT is open"
    exit 0
else
    echo "[-] FAILED: Port $TARGET_PORT is closed or filtered" >&2
    exit 1
fi
"""

    def save_script(self,
                   task: ExploitTask,
                   script_content: str,
                   language: str = "python") -> str:
        """
        Save script to file.

        Args:
            task: Task information
            script_content: Script code
            language: Script language

        Returns:
            Path to saved script
        """
        # Determine file extension
        ext_map = {
            "python": ".py",
            "python 3": ".py",
            "bash": ".sh",
            "shell": ".sh",
            "powershell": ".ps1"
        }
        ext = ext_map.get(language.lower(), ".py")

        # Generate filename
        filename = f"{task.task_id}{ext}"
        script_path = self.output_dir / filename

        # Write script
        script_path.write_text(script_content)

        # Make executable (Unix)
        if ext in [".py", ".sh"]:
            script_path.chmod(0o755)

        if self.verbose:
            print(f"    ✓ Saved to: {script_path}")

        return str(script_path)


def load_classification_output(experiment_report: str) -> List[Dict]:
    """
    Load classification results from experiment report.

    Args:
        experiment_report: Path to experiment_report.json

    Returns:
        List of classified findings
    """
    with open(experiment_report, 'r') as f:
        data = json.load(f)

    # Extract findings
    findings = []

    if 'findings' in data:
        findings = data['findings']
    elif 'vulnerabilities' in data:
        findings = data['vulnerabilities']
    elif 'results' in data:
        findings = data['results']
    else:
        # Assume entire JSON is findings list
        findings = data if isinstance(data, list) else []

    return findings


def main():
    parser = argparse.ArgumentParser(
        description="Generate exploit scripts from classification output"
    )

    parser.add_argument("--experiment-report", type=str, required=True,
                       help="Path to experiment_report.json")
    parser.add_argument("--output-dir", type=str, default="./exploits",
                       help="Output directory for scripts")
    parser.add_argument("--llm-provider", type=str, default="openai",
                       choices=["openai", "gemini", "local"],
                       help="LLM provider for script generation")
    parser.add_argument("--manifest-output", type=str, default="./exploits_manifest.json",
                       help="Output path for exploits manifest")
    parser.add_argument("--filter-cvss", type=float, default=0.0,
                       help="Only generate scripts for CVSS >= this value")
    parser.add_argument("--quiet", action="store_true",
                       help="Reduce output")

    args = parser.parse_args()

    verbose = not args.quiet

    print("="*70)
    print("EXPLOIT SCRIPT GENERATION FROM CLASSIFICATION")
    print("="*70)
    print(f"Experiment report: {args.experiment_report}")
    print(f"Output directory: {args.output_dir}")
    print(f"LLM provider: {args.llm_provider}")
    print(f"CVSS filter: >= {args.filter_cvss}")
    print("="*70 + "\n")

    # Initialize generator
    generator = LLMExploitScriptGenerator(
        llm_provider=args.llm_provider,
        output_dir=args.output_dir,
        verbose=verbose
    )

    # Load classification results
    print("[1/4] Loading classification results...")

    # Use existing experiment.py output if available
    # Otherwise parse from experiment report
    task_manager = TaskManager()

    # Try to load from experiment report
    try:
        findings_data = load_classification_output(args.experiment_report)
        print(f"  ✓ Loaded {len(findings_data)} findings from report")

        # Convert to VAFinding objects and create tasks
        from parser import VAFinding

        for finding_data in findings_data:
            # Create VAFinding from dict
            finding = VAFinding(**finding_data) if isinstance(finding_data, dict) else finding_data

            # Filter by CVSS if specified
            if finding.cvss_base_score and finding.cvss_base_score >= args.filter_cvss:
                task = task_manager.create_task_from_finding(finding)

        print(f"  ✓ Created {len(task_manager.tasks)} tasks (CVSS >= {args.filter_cvss})")

    except Exception as e:
        print(f"  ✗ Error loading classification: {e}")
        sys.exit(1)

    # Generate scripts
    print(f"\n[2/4] Generating exploit scripts ({len(task_manager.tasks)} tasks)...")

    generated_count = 0
    failed_count = 0

    for i, (task, finding) in enumerate(zip(task_manager.tasks, findings_data), 1):
        if verbose:
            print(f"\n[{i}/{len(task_manager.tasks)}]", end="")

        try:
            # Generate script
            script_content = generator.generate_script_for_task(finding, task)

            if script_content:
                # Determine language
                language = generator._determine_language(finding)

                # Save script
                script_path = generator.save_script(task, script_content, language)

                # Update task with script path
                task.exploit_script = script_path
                task.script_language = language

                generated_count += 1
            else:
                failed_count += 1
                if verbose:
                    print(f"    ✗ Failed to generate script")

        except Exception as e:
            failed_count += 1
            if verbose:
                print(f"    ✗ Error: {e}")

    print(f"\n  ✓ Generated {generated_count} scripts")
    if failed_count > 0:
        print(f"  ⚠ Failed: {failed_count} scripts")

    # Save manifest
    print(f"\n[3/4] Saving exploits manifest...")
    task_manager.save_tasks(args.manifest_output)
    print(f"  ✓ Saved to: {args.manifest_output}")

    # Summary
    print(f"\n[4/4] Summary:")
    print(f"  Total tasks: {len(task_manager.tasks)}")
    print(f"  Scripts generated: {generated_count}")
    print(f"  Failed: {failed_count}")
    print(f"  Success rate: {generated_count / len(task_manager.tasks) * 100:.1f}%")

    print("\n" + "="*70)
    print("SCRIPT GENERATION COMPLETE")
    print("="*70)
    print(f"\nNext steps:")
    print(f"1. Review generated scripts in: {args.output_dir}")
    print(f"2. Train PPO with:")
    print(f"   python training/train_ppo_llm_pentest.py \\")
    print(f"       --experiment-report {args.experiment_report} \\")
    print(f"       --exploits-manifest {args.manifest_output}")


if __name__ == "__main__":
    main()
